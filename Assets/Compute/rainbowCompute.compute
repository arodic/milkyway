#pragma kernel CSMain

#include "chunks/snoise.cginc"
#include "chunks/curlNoise.cginc"

struct Vertex {
  float3 position;
  float3 velocity;
  float3 color;
  float3 normal;
  float2 uv;
  float life;
  int id;
};
struct Index {
  int id0;
  int id1;
  int id2;
  int id3;
  int id4;
  int id5;
  int id6;
  int id7;
};

RWStructuredBuffer<Vertex> vertices;
StructuredBuffer<Index> indices;

float _Time;
float _Delta;
float _Resolution;
float _Damping;
float _Curl;
float _CurlFreq;
float _Spring;
float _Smooth;
float _Life;
float3 _Force0;
float3 _Force1;
float3 _Force2;
float3 _Force3;

#define PI 3.14159265359

float3 springForce( float3 p1 , float3 p2 , float d ){
  float3 dir = p1 - p2;
  float dist = length( dir );
  if( dist >= .000001 ){
    dir = normalize( dir );
    float dif = dist - d;
    return dif * dif * float(sign(dif)) * -dir;
  } else {
    return float3(0,0,0);
  }
}

[numthreads(128, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {


  int idx = vertices[id.x].id;
  Index i = indices[idx];

  vertices[i.id0].life = fmod(vertices[i.id0].life + _Delta / _Life, 1.0);
  if (vertices[i.id0].life < 0.0) return;

  float3 pos = vertices[i.id0].position;
  float3 pos1 = vertices[i.id1].position;
  float3 pos2 = vertices[i.id2].position;
  float3 pos3 = vertices[i.id3].position;
  float3 pos4 = vertices[i.id4].position;


  float3 velocity = vertices[i.id0].velocity;

  float3 right = pos1 - pos;
  float3 down = pos2 - pos;
  float3 left = pos3 - pos;
  float3 up = pos4 - pos;

  if (length(up) < 0.00001) { up = -down; }
  if (length(down) < 0.00001) { down = -up; }
  if (length(left) < 0.00001) { left = -right; }
  if (length(right) < 0.00001) { right = -left; }

  float3 n1 = cross(normalize(up), normalize(right));
  float3 n2 = cross(normalize(right), normalize(down));
  float3 n3 = cross(normalize(down), normalize(left));
  float3 n4 = cross(normalize(left), normalize(up));
  vertices[i.id0].normal = (n1 + n3);
  // vertices[i.id0].normal = n1;
  // vertices[i.id0].normal = (n1 + n2 + n3 + n4);

  velocity *= 1.0 - (1.0 * _Damping * _Delta);

  float forceCycle = fmod(vertices[i.id0].life, 1.0) * PI * 1.5;
  float force0 = max(0.0, sin(forceCycle + PI / 2.0));
  float force1 = max(0.0, sin(forceCycle));
  float force2 = max(0.0, sin(forceCycle + 3.*PI / 2.0));
  float force3 = max(0.0, sin(forceCycle + 2.*PI / 2.0));
  float3 force = force0 * _Force0;
  force += force1 * _Force1;
  force += force2 * _Force2;
  force += force3 * _Force3;
  // force += right * 0.01;
  velocity += force * _Delta * 0.05;

  float3 smooth = float3(0,0,0);
  smooth += up * pow(length(up) * 0.5, 2.0);
  smooth += right * pow(length(right) * 0.5, 2.0);
  smooth += down * pow(length(down) * 0.5, 2.0);
  smooth += left * pow(length(left) * 0.5, 2.0);
  velocity += smooth * _Smooth * _Delta * 50.0;

  float3 curl = curlNoise(pos * _CurlFreq + float3(0.0, _Time * 0.1, 0.0)) * 0.02;
  velocity += curl * _Curl * _Delta;
  // velocity += curl * _Curl * _Delta * (1.0 + length(force)) * 1.0;

  float3 spring = (float3)0;
  float d = 1.0 / _Resolution  + max(0.0, vertices[i.id0].life) * 0.2;
  // float d = 1.0 / _Resolution;
  spring += springForce(pos, pos1, d);
  spring += springForce(pos, pos2, d);
  spring += springForce(pos, pos3, d);
  spring += springForce(pos, pos4, d);
  velocity += spring * _Spring * _Delta;

  vertices[i.id0].velocity = velocity;

  if (length(velocity) > 0.001) {
    velocity = normalize(velocity) * min(length(velocity), 0.125);
  }
  vertices[i.id0].position += velocity;
}
