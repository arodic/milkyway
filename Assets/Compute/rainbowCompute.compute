#pragma kernel CSMain

#include "chunks/snoise.cginc"
#include "chunks/curlNoise.cginc"

struct Vertex {
  float3 position;
  float3 velocity;
  float3 color;
  float3 normal;
  float2 uv;
  float life;
  float debug;
};
struct Index {
  int id0;
  int id1;
  int id2;
  int id3;
  int id4;
  int id5;
  int id6;
  int id7;
};

RWStructuredBuffer<Vertex> vertices;
StructuredBuffer<Index> indices;

float _Time;
float _Delta;
float _Resolution;
float _Damping;
float _Curl;
float _CurlFreq;
float _Spring;
float _Smooth;

float3 springForce( float3 p1 , float3 p2 , float d ){
  float3 dir = p1 - p2;
  float dist = length( dir );
  if( dist >= .000001 ){
    dir = normalize( dir );
    float dif = dist - d;
    return dif * dif * float(sign(dif)) * -dir;
  } else {
    return float3(0,0,0);
  }
}

[numthreads(128, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
  Index i = indices[id.x];
  float3 pos = vertices[i.id0].position;
  float3 pos1 = vertices[i.id1].position;
  float3 pos2 = vertices[i.id2].position;
  float3 pos3 = vertices[i.id3].position;
  float3 pos4 = vertices[i.id4].position;


  float3 velocity = vertices[i.id0].velocity;

  float3 up = pos1 - pos;
  float3 right = pos2 - pos;
  float3 down = pos3 - pos;
  float3 left = pos4 - pos;

  vertices[i.id0].normal = cross(normalize(up), normalize(right));

  velocity *= 1.0 - (1.0 * _Damping * _Delta);

  float3 smooth = float3(0,0,0);
  smooth += up * pow(length(up) / 2.0, 2.0);
  smooth += right * pow(length(right) / 2.0, 2.0);
  smooth += down * pow(length(down) / 2.0, 2.0);
  smooth += left * pow(length(left) / 2.0, 2.0);
  velocity += smooth * _Smooth * _Delta * 10.0;

  float3 curl = curlNoise(pos * _CurlFreq + float3(0.0, _Time * 0.1, 0.0)) * 0.02;
  velocity += curl * _Curl * _Delta;

  float3 spring = (float3)0;
  float d = 1.0 / _Resolution;
  spring += springForce(pos, pos1, d);
  spring += springForce(pos, pos2, d);
  spring += springForce(pos, pos3, d);
  spring += springForce(pos, pos4, d);
  velocity += spring * _Spring * _Delta;

  if (length(velocity) > 0.001) {
    velocity = normalize(velocity) * min(length(velocity), 0.0125);
  }

  // float3 fwd = pos1 - pos;
  // if (length(fwd) < 0.000005) {
  //    fwd = -(pos3 - pos);
  // }
  // velocity += fwd * 0.0005;

  vertices[i.id0].velocity = velocity;

  vertices[i.id0].position += velocity;
}
